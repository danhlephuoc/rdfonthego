#summary RDF On The Go setting up and evaluation.

= Introduction =

This tutorial explains how to set up the RDF On The Go for an Android application and how we did the experiences on that.

=1.Setting up an Android application with RDF OTG=
This new version of RDF OTG provides native RDF storage and Sparql querying engine for Android platform. Thus, all you will need to add into your Android application are just two jar files below:

- <a href='https://rdfonthego.googlecode.com/files/otg_rdf_core.jar'>otg_rdf_core.jar</a> - The native RDF store for Android platform.

- <a href='https://rdfonthego.googlecode.com/files/otg_arq.jar'>otg_arq.jar </a> - The spaql query engine which is ported from Jena ARQ with some modifications in order to pair with RDF OTG.

* Note: Requires Android 2.3.3 or later version and WRITE_EXTERNAL_STORAGE permisson has to be added in the Android project.

==2. Setting up for evaluations==

===2.1 Social network generation===
 For data simulations, we used <a href='http://sourceforge.net/projects/sibenchmark/'> Social Intelligence Benchmark(SIB) tool</a> which takes the schema style from popular social networks such as Facebook as the baseline for designing an RDF-friendly, scientific benchmark. Specifically, it simulates an RDF backend of a social network site, in which users and their interactions form an social graph of social activities such as writing posts, posting comments, creating/managing groups, etc.
 
 The number of users could be change in the parameter file - params.ini. And we also modified name space, the number of friends, the number of photos, posts, comments in order to simulate different network. Example www.facebook.com for facebook, www.linkedin.com for Linkedin, etc. The triples will be saved into text file with n-triples format. The simulated data for our evaluation could be found <a href= 'https://rdfonthego.googlecode.com/files/social%20dataset.rar'>here</a>


===2.2 Update throughput evaluation===
After generating the simulated graph, we put the n-triples data files into SD card under folder 'Experience'. On Galaxy and Nexus, we can put them into their virtual removable storage. The Android OS will create an virtual path to copied directory and treat it as it is in the external storage. Thus we can get access to these files by the same way on 3 devices.

{{{
 String loading_path = Environment.getExternalStorageDirectory() + "/Experience/";
}}}

*Note: 

You can install <a href= 'https://play.google.com/store/apps/details?id=org.openintents.filemanager&feature=search_result#?t=W251bGwsMSwxLDEsIm9yZy5vcGVuaW50ZW50cy5maWxlbWFuYWdlciJd'>IO File Manager</a> the check if the files are already copied into the storage.

In RDF OTG, we also plugged  Jena Riot Loader in case of parsing RDF from n-triples format. In first experiment, for evaluating throughput of inserting data. We created a graph with about 1500 users which contains about one million triples and parse into the store, then we measure the insertion speed. The codes of experiment are in the scripts below: 

{{{ 
 //TDB JENA
 public static void start(){
 String loading_path = Environment.getExternalStorageDirectory() + "/Experience/";
 String store_path   = Environment.getExternalStorageDirectory() + "/JenaTDB/";
 Graph graph = TDBFactory.createGraph(store_path);
 FileUtil fileUtil = new FileUtil("JenaTDB_1_Ex");
 BufferedReader in;
 ParserTurtle parser = new ParserTurtle();
 try {
	    fileUtil.start();
	    for (int i = 1; i < 100; i++) {
	        fileUtil.write(graph.size());   
	        int k = 1700000 + i;
		in = new BufferedReader(new FileReader(loading_path + "mr0_fb" + Integer.toString(k) + ".nt"));
		parser.parse(graph, " ", in);
		fileUtil.write(graph.size());
		TDB.sync(graph);
	    }
	    fileUtil.close();
	} catch (IOException e) {
	    e.printStackTrace();
	}
    }
}}}

{{{ 
 //RDF OTG
 String load_path = Environment.getExternalStorageDirectory() + "/Experience/";
 String store_Path = Environment.getExternalStorageDirectory() + "/RDF_OTG/";
 public static void start() {
        Graph graph = new OTGGraph(store_path);
	FileUtil fileUtil = new FileUtil("RDF_OTG_1_Ex");
	try {
	    fileUtil.start();
	    fileUtil.write(graph.size());
	    for (int i = 1; i < 100; i++) {
	        fileUtil.write(graph.size());
		int k = 1700000 + i;
		RiotLoader.read(loading_path + "mr0_fb" + Integer.toString(k) + ".nt", graph);
		fileUtil.write(graph.size());
		graph.sync();
	    }
	    fileUtil.close();
	} catch (IOException e) {
	    e.printStackTrace();
	}
    }
}}}

The experiments stopped when the loading finishes or the application crashes due to out of heap memory.

===2.3 Comparing query evaluation===
For evaluating the query processor. We implemented 
{{{
package deri.org.ad_hoc;

import android.os.Environment;

import com.hp.hpl.jena.graph.Graph;
import com.hp.hpl.jena.graph.Node;
import com.hp.hpl.jena.graph.Triple;
import com.hp.hpl.jena.graph.TripleMatch;
import com.hp.hpl.jena.graph.impl.GraphBase;
import com.hp.hpl.jena.sparql.vocabulary.FOAF;
import com.hp.hpl.jena.tdb.TDB;
import com.hp.hpl.jena.tdb.TDBFactory;
import com.hp.hpl.jena.tdb.store.DatasetGraphTDB;
import com.hp.hpl.jena.tdb.store.GraphNamedTDB;
import com.hp.hpl.jena.util.iterator.ExtendedIterator;
import com.hp.hpl.jena.vocabulary.OWL;
import com.hp.hpl.jena.vocabulary.RDF;

public class JenaMasterGraph extends GraphBase {
    public Graph sourceGraph;
    public Graph unifiedGraph;
    public Graph sameAsGraph;
    public final String globalPath = Environment.getExternalStorageDirectory() + "/Jena/";
    
    
    public JenaMasterGraph(){
	unifiedGraph = TDBFactory.createNamedGraph("unified", globalPath);
	sameAsGraph  = TDBFactory.createNamedGraph("sameAs", globalPath);
    }
    
    public JenaMasterGraph(String name) {
	unifiedGraph = TDBFactory.createNamedGraph("unified", globalPath);
	sourceGraph  = TDBFactory.createNamedGraph(name, globalPath);
	sameAsGraph  = TDBFactory.createNamedGraph("sameAs", globalPath);
    }

    public void add(Triple t) {
	Node s = t.getSubject();
	Node p = t.getPredicate();
	Node o = t.getObject();

	Node masterSubject;
	Node masterObject;
	if (p.toString().contains(RDF.type.toString())) {
	    if (o.toString().contains(FOAF.Person.toString())) {
		masterSubject = getMasterNode(s);
		if (masterSubject == null) {
		    // if no masterNode of this
		    // create a new masterNOde
		    masterSubject = Node.createURI(s.getURI() + "/master");
		    // replace the master in unified Graph
		    replaceSubject(masterSubject, s);
		    replaceObject(masterSubject, s);
		    // input new master Node to sameAs graph
		    sameAsGraph.add(new Triple(masterSubject, OWL.sameAs.asNode(), s));
		} else {
		    replaceSubject(masterSubject, s);
		    replaceObject(masterSubject, s);
		}
	    }
	}

	if (p.equals(FOAF.mbox.asNode())) {
	    if (o.getLiteralLexicalForm().equals("mailto:"))
		return;
	    IPF_merging(t);

	}

	if ((s.isURI()) || (s.isBlank())) {
	    masterSubject = getMasterNode(s);
	    if (masterSubject == null) {
		masterSubject = s;
	    }
	} else {
	    masterSubject = s;
	}

	if ((o.isURI()) || (o.isBlank())) {
	    masterObject = getMasterNode(o);
	    if (masterObject == null) {
		masterObject = o;
	    }
	} else {
	    masterObject = o;
	}

	if (p.equals(OWL.sameAs.asNode())) {
	    mergeSameAs(masterSubject, masterObject);
	    replaceSubject(masterSubject, masterObject);
	    replaceObject(masterSubject, masterObject);
	}

	Triple masterTriple = new Triple(masterSubject, p, masterObject);
	unifiedGraph.add(masterTriple);
	sourceGraph.add(t);
	
    }

    public void IPF_merging(Triple t) {
	ExtendedIterator<Triple> triples = unifiedGraph.find(Node.ANY, t.getPredicate(), t.getObject());
	if (triples.hasNext()) {
	    Triple tm = triples.next();
	    if (tm.getSubject().equals(t.getSubject())) {
		return;
	    } else {
		Node removeSubject = getMasterNode(t.getSubject());
		if (removeSubject == null) {
		    replaceSubject(tm.getSubject(), t.getSubject());
		    replaceObject(tm.getObject(), t.getObject());
		} else {
		    replaceSubject(tm.getSubject(), removeSubject);
		    replaceObject(tm.getSubject(), removeSubject);
		    mergeSameAs(tm.getSubject(), removeSubject);
		}
	    }
	}
    }

    private Node getMasterNode(Node node) {
	ExtendedIterator<Triple> triples = sameAsGraph.find(Node.ANY, Node.ANY, node);
	if (triples.hasNext()) {
	    Triple t = triples.next();
	    return t.getSubject();
	} else {
	    return null;
	}
    }

    private void mergeSameAs(Node masterNodeKeep, Node masterNodeRemove) {
	if (masterNodeKeep.equals(masterNodeRemove)) {return;}
	
	while (true) {
	    ExtendedIterator<Triple> triples = sameAsGraph.find(masterNodeRemove, Node.ANY, Node.ANY);
	    if (triples.hasNext()) {
		Triple t = triples.next();
		Triple tkeep = new Triple(masterNodeKeep, t.getPredicate(), t.getObject());
		sameAsGraph.add(tkeep);
		sameAsGraph.delete(t);
	    } else {
		break;
	    }
	}
    }

    private void replaceSubject(Node keep, Node remove) {
	if (keep.equals(remove)) return;
	while (true) {
	    ExtendedIterator<Triple> triples = unifiedGraph.find(remove, Node.ANY, Node.ANY);
	    if (triples.hasNext()) {
		Triple t = triples.next();
		Triple tkeep = new Triple(keep, t.getPredicate(), t.getObject());
		unifiedGraph.add(tkeep);
		unifiedGraph.delete(t);
		
	    } else {
		break;
	    }
	}
    }

    private void replaceObject(Node keep, Node remove) {
	if (keep.equals(remove)) return;
	while (true) {
	    ExtendedIterator<Triple> triples = unifiedGraph.find(Node.ANY, Node.ANY, remove);
	    if (triples.hasNext()) {
		Triple t = triples.next();
		Triple tkeep = new Triple(t.getSubject(), t.getPredicate(), keep);
		unifiedGraph.add(tkeep);
		unifiedGraph.delete(t);
	    } else {
		break;
	    }
	}
    }

    public void sync() {
	TDB.sync(unifiedGraph);
	TDB.sync(sourceGraph);
	TDB.sync(sameAsGraph);
    }

    @Override
    protected ExtendedIterator<Triple> graphBaseFind(TripleMatch m) {
	Node ms = m.getMatchSubject();
	Node mp = m.getMatchPredicate();
	Node mo = m.getMatchObject();
	
	if (ms == null) {
	    ms = Node.ANY; 
	}else{
	    Node n = getMasterNode(ms);
	    if (n !=null){
		ms = n;
	    }
	}
	
	if (mp == null) {
	    mp = Node.ANY; 
	}
	
	if (mo == null) {
	    mo = Node.ANY; 
	}else{
	    Node n = getMasterNode(mo);
	    if (n !=null){
		mo = n;
	    }
	}
	
	Triple mm = new Triple (ms, mp, mo);
	return unifiedGraph.find(mm);
    }
    
    public void close(){
	unifiedGraph.close();
	sameAsGraph.close();
	sourceGraph.close();
    }
}



}}}
===2.4 Scalability evaluation===